(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{188:function(t,n,e){"use strict";e.r(n);var r=e(0),s=Object(r.a)({},function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"content"},[e("h3",{attrs:{id:"算法图解"}},[t._v("算法图解")]),t._v(" "),e("h3",{attrs:{id:"_1-简介："}},[t._v("1 简介：")]),t._v(" "),e("p",[t._v("一般谈到复杂度较优的查找算法 都会想到介 -- 二分查找（tips: 所有的算法都用它的适用场景，遇到问题要先分析问题具体场景，否则方法再牛只是画蛇添足！ ）。\nwhat is ‘二分查找’？\n👇👇")]),t._v(" "),t._m(0),e("p",[t._v("下面介绍1下，what is ‘大O’ ？\n对，大O  一般用来表示算法复杂度（时间复杂度，空间复杂度）\n下面列出常见的5种大O运行时间\n👇👇")]),t._v(" "),t._m(1),e("h3",{attrs:{id:"_2-数组-链表："}},[t._v("2 数组&&链表：")]),t._v(" "),e("p",[t._v("数组-- 在内存空间中地址始终是连续的（索引值与内存地址都是连续的），并且数组长度扩大时 会开辟一块新长度的内存空间，因此访问操作时效率较高，插入删除操作时效性能较差。\n链表-- 在内存空间中地址可以间断，因此插入，删除操作时效率较高，访问操作时效率较低（因为需要从头进行遍历查找）。")]),t._v(" "),t._m(2),t._v(" "),e("h3",{attrs:{id:"_3-递归："}},[t._v("3 递归：")]),t._v(" "),e("p",[t._v("递归由两部分组成：")]),t._v(" "),t._m(3),t._v(" "),e("p",[t._v("举个🌰，常见的递归算法")]),t._v(" "),t._m(4),e("p",[t._v("很明显此递归方法中--  1. 结束条件  2. 调用自身")]),t._v(" "),e("p",[t._v("but...使用递归很方便，但是要付出代价：存储详尽的信息需要占用大量的内存。递归中函数会嵌套执行多层函数，每个函数调用都要占用一定的内存，如果栈很高，计算机就需要存储大量函数调用的信息，这就是为什么有的语言会限制递归最多的层数.")]),t._v(" "),t._m(5),t._v(" "),t._m(6),e("p",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/04/tail-call.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("尾调用优化"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("通过变量保存函数运算结果，然后通过参数传递给下层递归函数，如果可以确切的知道下层函数需要从上层函数得到什么信息，则可把所有用到的内部变量改写成函数的参数，构成尾递归")]),t._v(" "),e("h3",{attrs:{id:"_4-快速排序："}},[t._v("4 快速排序：")]),t._v(" "),t._m(7),t._v(" "),t._m(8),e("h3",{attrs:{id:"_5-散列表-object-dict"}},[t._v("5 散列表  Object/dict")]),t._v(" "),e("h3",{attrs:{id:"_6-广度优先搜索-graph"}},[t._v("6 广度优先搜索 graph")]),t._v(" "),e("h3",{attrs:{id:"_7-狄克斯拉特算法"}},[t._v("7 狄克斯拉特算法")]),t._v(" "),e("h3",{attrs:{id:"_8-贪婪算法（np完全问题）"}},[t._v("8 贪婪算法（NP完全问题）")]),t._v(" "),e("h3",{attrs:{id:"_9-动态规划-（背包问题）"}},[t._v("9 动态规划 （背包问题）")]),t._v(" "),e("h3",{attrs:{id:"_10-k最近邻算法-（推荐系统）"}},[t._v("10 K最近邻算法 （推荐系统）")])])},[function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("/* 二分查找 */\nfunction binarySearch(arr = [], item) {\n  let low = 0,\n    high = arr.length - 1;\n  while (low <= high) {\n    const mid = parseInt((low + high) / 2);\n    const guess = arr[mid];\n    if (guess === item) {\n      return mid;\n    }\n    if (guess > item) {\n      high = mid - 1;\n    }\n    if (guess < item) {\n      low = mid + 1;\n    }\n  }\n  return null;\n}\n\nconst myList = [1, 3, 5, 7, 9];\nconsole.log(binarySearch(myList, 3));\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("O(log n):也叫对数时间，这样的算法包括二分查找；\nO(n):也叫线性时间，这样的算法包括简单查找；\nO(n * log n): 这种算法包括快速排序 —— 一种速度较快的排序算法；\nO(n²):这样的算法包括选择排序 —— 一种速度较慢的排序算法；\nO(n!): 这样的算法包括难以解决的旅行商问题 —— 一种非常慢的算法。（旅行商问题  感兴趣的可以研究一下狄克斯拉特算法 Dijstra's algorithm）\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("链表和数组各种操作的时间复杂度对比\n"),n("br"),this._v(" "),n("img",{attrs:{src:"https://user-images.githubusercontent.com/25975076/49274715-311bdb80-f4b4-11e8-9359-bc3395e3e402.png",alt:"image"}})])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("基线条件（base case）：函数不再调用自己的条件")]),this._v(" "),n("li",[this._v("递归条件（recursive case）: 函数调用自己的条件")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("/*斐波纳契数列*/\n  function fib(n){\n        if(n<1)  return\n        if (n <=2) {\n          return 1\n        } else {\n          return fib(n-1)*fib(n-2)\n        }\n      }\n")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("blockquote",[n("p",[this._v("顺便开个小灶 —— 介绍下   "),n("code",[this._v("尾调用优化")])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，\n这将大大节省内存。这就是"尾调用优化"的意义。\n')])])])},function(){var t=this.$createElement,n=this._self._c||t;return n("ul",[n("li",[this._v("选择基准值")]),this._v(" "),n("li",[this._v("将数组分为两个子数组，小于基准值的元素和大于基准值的元素")]),this._v(" "),n("li",[this._v("对两个子数组再次运用快速排序")])])},function(){var t=this.$createElement,n=this._self._c||t;return n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("function quickSort(arr){\n        if(arr.length<=1) {\n          return arr;\n        }\n        let q = arr[0];\n        let left = [];\n        let right = [];\n        for(let i=1,len=arr.length;i<len;i++){\n          if(arr[i]<q){\n            left.push(arr[i]);\n          }else{\n            right.push(arr[i]);\n          }\n        }\n        return [].concat(quickSort(left), [q], quickSort(right));\n      }\n var result = quickSort([1,5,7,90,55,4,2]);\n")])])])}],!1,null,null,null);s.options.__file="2018-12.md";n.default=s.exports}}]);