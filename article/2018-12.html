<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法图解 | Blog</title>
    <meta name="description" content="">
    <link rel="icon" href="./logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.bed5c7ac.css" as="style"><link rel="preload" href="/assets/js/app.04639768.js" as="script"><link rel="preload" href="/assets/js/15.050545d0.js" as="script"><link rel="prefetch" href="/assets/js/1.637a0146.js"><link rel="prefetch" href="/assets/js/10.455faaf1.js"><link rel="prefetch" href="/assets/js/11.56ac4116.js"><link rel="prefetch" href="/assets/js/12.7d41fdbe.js"><link rel="prefetch" href="/assets/js/13.2f0f41ef.js"><link rel="prefetch" href="/assets/js/14.56e43344.js"><link rel="prefetch" href="/assets/js/16.224269a6.js"><link rel="prefetch" href="/assets/js/17.bb220c86.js"><link rel="prefetch" href="/assets/js/18.d4e17f15.js"><link rel="prefetch" href="/assets/js/19.ec68a558.js"><link rel="prefetch" href="/assets/js/2.2b9de9f7.js"><link rel="prefetch" href="/assets/js/20.68351d5a.js"><link rel="prefetch" href="/assets/js/4.9d390a5a.js"><link rel="prefetch" href="/assets/js/5.7e4683a9.js"><link rel="prefetch" href="/assets/js/6.20717ae2.js"><link rel="prefetch" href="/assets/js/7.ebbc1056.js"><link rel="prefetch" href="/assets/js/8.728c7886.js"><link rel="prefetch" href="/assets/js/9.77251d8f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bed5c7ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/article/" class="nav-link router-link-active">Article</a></div><div class="nav-item"><a href="/about/" class="nav-link">AboutMe</a></div><div class="nav-item"><a href="https://github.com/ronghaoZHI" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/myLove/" class="nav-link"></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/article/" class="nav-link router-link-active">Article</a></div><div class="nav-item"><a href="/about/" class="nav-link">AboutMe</a></div><div class="nav-item"><a href="https://github.com/ronghaoZHI" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/myLove/" class="nav-link"></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>文章</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/article/2018-12-12.html" class="sidebar-link">DNS解析顺序</a></li><li><a href="/article/2018-12-04.html" class="sidebar-link">VuePress 实践</a></li><li><a href="/article/2018-12.html" class="active sidebar-link">算法图解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/article/2018-11.html" class="sidebar-link">web worker</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h3 id="算法图解">算法图解</h3> <h3 id="_1-简介：">1 简介：</h3> <p>一般谈到复杂度较优的查找算法 都会想到介 -- 二分查找（tips: 所有的算法都用它的适用场景，遇到问题要先分析问题具体场景，否则方法再牛只是画蛇添足！ ）。
what is ‘二分查找’？
👇👇</p> <div class="language- extra-class"><pre class="language-text"><code>/* 二分查找 */
function binarySearch(arr = [], item) {
  let low = 0,
    high = arr.length - 1;
  while (low &lt;= high) {
    const mid = parseInt((low + high) / 2);
    const guess = arr[mid];
    if (guess === item) {
      return mid;
    }
    if (guess &gt; item) {
      high = mid - 1;
    }
    if (guess &lt; item) {
      low = mid + 1;
    }
  }
  return null;
}

const myList = [1, 3, 5, 7, 9];
console.log(binarySearch(myList, 3));
</code></pre></div><p>下面介绍1下，what is ‘大O’ ？
对，大O  一般用来表示算法复杂度（时间复杂度，空间复杂度）
下面列出常见的5种大O运行时间
👇👇</p> <div class="language- extra-class"><pre class="language-text"><code>O(log n):也叫对数时间，这样的算法包括二分查找；
O(n):也叫线性时间，这样的算法包括简单查找；
O(n * log n): 这种算法包括快速排序 —— 一种速度较快的排序算法；
O(n²):这样的算法包括选择排序 —— 一种速度较慢的排序算法；
O(n!): 这样的算法包括难以解决的旅行商问题 —— 一种非常慢的算法。（旅行商问题  感兴趣的可以研究一下狄克斯拉特算法 Dijstra's algorithm）
</code></pre></div><h3 id="_2-数组-链表：">2 数组&amp;&amp;链表：</h3> <p>数组-- 在内存空间中地址始终是连续的（索引值与内存地址都是连续的），并且数组长度扩大时 会开辟一块新长度的内存空间，因此访问操作时效率较高，插入删除操作时效性能较差。
链表-- 在内存空间中地址可以间断，因此插入，删除操作时效率较高，访问操作时效率较低（因为需要从头进行遍历查找）。</p> <p>链表和数组各种操作的时间复杂度对比
<br> <img src="https://user-images.githubusercontent.com/25975076/49274715-311bdb80-f4b4-11e8-9359-bc3395e3e402.png" alt="image"></p> <h3 id="_3-递归：">3 递归：</h3> <p>递归由两部分组成：</p> <ul><li>基线条件（base case）：函数不再调用自己的条件</li> <li>递归条件（recursive case）: 函数调用自己的条件</li></ul> <p>举个🌰，常见的递归算法</p> <div class="language- extra-class"><pre class="language-text"><code>/*斐波纳契数列*/
  function fib(n){
        if(n&lt;1)  return
        if (n &lt;=2) {
          return 1
        } else {
          return fib(n-1)*fib(n-2)
        }
      }
</code></pre></div><p>很明显此递归方法中--  1. 结束条件  2. 调用自身</p> <p>but...使用递归很方便，但是要付出代价：存储详尽的信息需要占用大量的内存。递归中函数会嵌套执行多层函数，每个函数调用都要占用一定的内存，如果栈很高，计算机就需要存储大量函数调用的信息，这就是为什么有的语言会限制递归最多的层数.</p> <blockquote><p>顺便开个小灶 —— 介绍下   <code>尾调用优化</code></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，
这将大大节省内存。这就是&quot;尾调用优化&quot;的意义。
</code></pre></div><p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener noreferrer">尾调用优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>通过变量保存函数运算结果，然后通过参数传递给下层递归函数，如果可以确切的知道下层函数需要从上层函数得到什么信息，则可把所有用到的内部变量改写成函数的参数，构成尾递归</p> <h3 id="_4-快速排序：">4 快速排序：</h3> <ul><li>选择基准值</li> <li>将数组分为两个子数组，小于基准值的元素和大于基准值的元素</li> <li>对两个子数组再次运用快速排序</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function quickSort(arr){
        if(arr.length&lt;=1) {
          return arr;
        }
        let q = arr[0];
        let left = [];
        let right = [];
        for(let i=1,len=arr.length;i&lt;len;i++){
          if(arr[i]&lt;q){
            left.push(arr[i]);
          }else{
            right.push(arr[i]);
          }
        }
        return [].concat(quickSort(left), [q], quickSort(right));
      }
 var result = quickSort([1,5,7,90,55,4,2]);
</code></pre></div><h3 id="_5-散列表-object-dict">5 散列表  Object/dict</h3> <h3 id="_6-广度优先搜索-graph">6 广度优先搜索 graph</h3> <h3 id="_7-狄克斯拉特算法">7 狄克斯拉特算法</h3> <h3 id="_8-贪婪算法（np完全问题）">8 贪婪算法（NP完全问题）</h3> <h3 id="_9-动态规划-（背包问题）">9 动态规划 （背包问题）</h3> <h3 id="_10-k最近邻算法-（推荐系统）">10 K最近邻算法 （推荐系统）</h3></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/article/2018-12-04.html" class="prev">
          VuePress 实践
        </a></span> <span class="next"><a href="/article/2018-11.html">
          web worker
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/15.050545d0.js" defer></script><script src="/assets/js/app.04639768.js" defer></script>
  </body>
</html>
